#include <iostream>

using namespace std;

const int N = 1e5 + 10;

int n, m;
int p[N], d[N]; // p[]寻找祖宗节点，d[]求到祖宗节点的距离

int find(int x) {
    if (p[x] != x) {
        // 更新以后，当前节点x到根节点的距离，相当于其到父节点的距离+父节点到根节点的距离。
        // t暂时存一下p[x]根节点，辅助变量。调用过程是递归的，相当于是从根节点向下维护。
        int t = find(p[x]);
        // d[x]中存储的始终是其到父节点的距离，而递归更新后，每个d[x]一定是其到跟节点的距离
        d[x] += d[p[x]];
        // 如果直接在上面把p[x]换掉，那就得不到d[p[x]]，如果上面保存的是距离，那那个距离不一定是到根节点的
        p[x] = t;
    }
    return p[x];
}

// 不行，因为这个路径的长度（高度），是需要自上而下加起来的，从根节点往下走
// 所以要先调用递归

// int find(int x)
// {
//     if (p[x] != x)
//     {
//         d[x] += d[p[x]];    // 更新距离
//         p[x] = find(p[x]);
//     }
//     return p[x];
// }

int main() {
    scanf("%d%d", &n, &m);

    for (int i = 1; i <= n; i++) p[i] = i;

    int res = 0; // 记录错误数
    while (m--) {
        int t, x, y;
        scanf("%d%d%d", &t, &x, &y);

        if (x > n || y > n)
            res++; // 当前的话中X或Y比N大，是假话
        else {
            int px = find(x), py = find(y); // 查找根节点
            if (t == 1) // 判断是否同类
            {
                if (px == py) { // 若 x 与 y 在同一个集合中
                    if ((d[x] - d[y]) % 3) res++; // 两数到根节点距离之差的模不为 0，说明不是同一类，是假话
                    // 其中 (d[x] - d[y]) % 3 不可写为 d[x] % 3 != d[y] % 3
                    // 因为 d[x], d[y] 可能为负数（一正一负），可改做 (d[x] % 3 + 3) % 3 != (d[y] % 3 + 3) % 3
                    // 负数 mod 正数为负数
                } else { // 则 x 与 y 不在同一个集合中
                    p[px] = py; // x 所在集合 合并到 y 所在集合
                    // 合并以后，有 d[x]和d[y]在%3的情况下为0。
                    // 也即 (d[x]+d[p[x]]-d[y])%3==0
                    d[px] = d[y] - d[x];
                    // d[x] 的距离为什么不更新？
                    // 只是暂时不更新，在调用 find 时再更新
                }
            } else // X 是否吃 Y
            {
                if (px == py) { // 若 x 与 y 在同一个集合中
                    // 若 X 吃 Y，则 d[x] 比 d[y] 大 1
                    if ((d[x] - d[y] - 1) % 3) res++; // 若距离之差 - 1 的模不为 0，说明吃不掉，是假话
                } else { // 则 x 与 y 不在同一个集合中
                // 合并不是乱合并的，一定主要好谁吃谁
                // x吃y因此是x合并到里。
                // 如果y合并到x里，那么距离计算要有改动
                    p[px] = py;
                    // (d[x] - d[y] - 1) % 3 == 0
                    // d[x] + d[px] - 1 = d[y]  则：
                    d[px] = d[y] + 1 - d[x];
                }
            }
        }
    }

    printf("%d\n", res);

    return 0;
}
